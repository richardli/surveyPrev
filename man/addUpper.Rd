% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/helperGeoBoundaries.R
\name{addUpper}
\alias{addUpper}
\title{Attach upper-level admin names to lower-level polygons}
\usage{
addUpper(
  poly.adm.upper,
  poly.adm,
  by.adm,
  by.adm.upper,
  out_lower = "NAME_2",
  out_upper = "NAME_1",
  sort = TRUE
)
}
\arguments{
\item{poly.adm.upper}{Spatial polygons for the *upper* admin level
(e.g., Admin 1 when the desired output is Admin 2). Can be an
\code{sf} object or an \code{sp::SpatialPolygonsDataFrame}.}

\item{poly.adm}{Spatial polygons for the *target* admin level you want
returned (e.g., Admin 2). Can be an \code{sf} object or an
\code{sp::SpatialPolygonsDataFrame}.}

\item{by.adm}{Character scalar. Column name in \code{poly.adm} that contains
the admin names for the target level (e.g., \code{"NAME_2"}).}

\item{by.adm.upper}{Character scalar. Column name in \code{poly.adm.upper}
that contains the admin names for the upper level (e.g., \code{"NAME_1"}).}

\item{out_lower}{Character scalar. Name of the output column to hold the
lower-level names in the returned object. Defaults to \code{"NAME_2"}.}

\item{out_upper}{Character scalar. Name of the output column to hold the
upper-level names in the returned object. Defaults to \code{"NAME_1"}.}

\item{sort}{Logical. If \code{TRUE} (default), alphabetically sorts the
output by \code{out_upper} then \code{out_lower}.}
}
\value{
An \code{sf} object at the target (lower) admin level containing:
\itemize{
  \item \code{out_lower}: lower-level admin name (copied from \code{by.adm})
  \item \code{out_upper}: upper-level admin name (derived via spatial matching)
  \item \code{geometry}: polygon geometry
  \item \code{admin2.name.full}: convenience concatenation
        \code{paste0(out_upper, "_", out_lower)}
}
}
\description{
Maps each polygon in a lower administrative layer (e.g., ADM2) to its
containing polygon in an upper layer (e.g., ADM1), populating an upper-level
name column. If containment fails for some polygons (e.g., due to slivers or
minor topology issues), a nearest-centroid fallback is used.
}
\details{
Inputs may be either \code{sf} or \code{sp} polygon data. If \code{sp} inputs
are provided, they are converted to \code{sf} internally. Containment is
determined via \code{sf::st_within()}. For polygons not matched by containment,
the function uses \code{sf::st_nearest_feature()} on centroids
(\code{sf::st_centroid()}) to assign an upper-level name.
}
\examples{
\dontrun{
library(sf)
adm1 <- st_read("geoBoundaries/geoBoundaries-NGA-ADM1-all/geoBoundaries-NGA-ADM1.shp")
adm2 <- st_read("geoBoundaries/geoBoundaries-NGA-ADM2-all/geoBoundaries-NGA-ADM2.shp")

# If both layers use "shapeName" but you want outputs named NAME_1/NAME_2:
res <- addUpper(
  poly.adm.upper = adm1,
  poly.adm       = adm2,
  by.adm         = "shapeName",   # lower-level names
  by.adm.upper   = "shapeName",   # upper-level names
  out_lower      = "NAME_2",
  out_upper      = "NAME_1",
  sort           = TRUE
)

# If the columns are already NAME_1 / NAME_2:
res2 <- addUpper(
  poly.adm.upper = adm1,
  poly.adm       = adm2,
  by.adm         = "NAME_2",
  by.adm.upper   = "NAME_1"
)
}


}
